\section{Ordonnancement par priorités}

\subsection{Choix dans la politique d'ordonnancement}

Notre ordonnanceur à priorités gère deux niveaux de priorités pour un processus :

\begin{itemize}
	\item La priorité système, avec le champ \texttt{priority};
	\item La priorité utilisateur, avec le champ \texttt{nice}.
\end{itemize}

Nous avons fait le choix de donner la priorité à la priorité système plutôt qu'à la priorité utilisateur.
Les deux priorités fonctionnent de la même manière : plus le champ priorité est bas, plus le processus est prioritaire.
\\

Nous avons également pensé au problème que représente la famine : dans la politique d'ordonnancement par priorités, un processus prioritaire peut ne jamais donner la main aux autres processus.
C'est pourquoi nous avons modifié légèrement la politique:

On fait la soustraction de la priorité système par le temps d'attente de chaque processus : ainsi, le processus qui a attendu le plus en fonction de sa priorité système aura la main sur le processeur.
À priorité système égale et temps d'attente égale, on considère la priorité utilisateur.
À priorité utilisateur égale, on applique la politique d'ordonnancement de type tourniquet.
\\

\subsection{Implémentation de la politique}

Ci-après, le code de la politique :

\begin{lstlisting}
/**
 * @brief Yields the processor.
 */
PUBLIC void yield(void)
{
	struct process *p;    /* Working process.     */
	struct process *next; /* Next process to run. */

	/* Re-schedule process for execution. */
	if (curr_proc->state == PROC_RUNNING)
		sched(curr_proc);

	/* Remember this process. */
	last_proc = curr_proc;

	/* Check alarm. */
	for (p = FIRST_PROC; p <= LAST_PROC; p++)
	{
		/* Skip invalid processes. */
		if (!IS_VALID(p))
			continue;

		/* Alarm has expired. */
		if ((p->alarm) && (p->alarm < ticks))
			p->alarm = 0, sndsig(p, SIGALRM);
	}
	

	/* Choose a process to run next. */
	next = IDLE;
	for (p = FIRST_PROC; p <= LAST_PROC; p++)
	{
		/* Skip non-ready process. */
		if (p->state != PROC_READY)
			continue;

		p->counter++; // Time to wait increased

		/* In order to prevent starvation,
		 * a job that waited the longest
		 * time has priority.
		 */
		int prioTimeP = p->priority - p->counter;
		int prioTimeNext = next->priority - next->counter;

			// IDLE must be replaced by a job waiting.
		if (	(next == IDLE)
			   // Starvation prevention
			|| (prioTimeP < prioTimeNext)
			   // If the priority is the same,
			   // let's consider the user priority
			|| (p->priority == next->priority
				&& p->nice < next->nice)
			   // If the user priority is the same,
			   // Round Robin
			|| (p->priority == next->priority
				&& p->nice == next->nice
				&& p-> counter >= next->counter)
		   )
			next = p;
	}

	/* Switch to next process. */
	next->priority = PRIO_USER;
	next->state = PROC_RUNNING;
	next->counter = PROC_QUANTUM;
	if (curr_proc != next)
		switch_to(next);
}
\end{lstlisting}

\subsection{Les problèmes rencontrés}

Nous avons passé beaucoup de temps sur cet ordonnanceur, car nous avions du mal à comprendre pourquoi nous obtenions le message \texttt{core dumped} sur notre première version d'implémentation.
Ce message indiquait qu'il y avait des surcharges mémoires au niveau utilisateur.
Cela était dû au fait que les compteurs d'attente des processus s'incrémentaient après l'analyse des priorités.
